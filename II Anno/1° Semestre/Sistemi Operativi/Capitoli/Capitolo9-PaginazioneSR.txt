CAPITOLO 9:  MEMORIA VIRTUALE 
 
La memoria virtuale è una tecnica che permette di eseguire processi che possono anche non essere completamente contenuti in memoria. Il vantaggio principale offerto da questa tecnica è quello di permettere che i programmi siano più grandi della memoria fisica; inoltre la memoria virtuale astrae la memoria centrale in un vettore di memorizzazione molto grande e uniforme,separando la memoria logica, com’è vista dall’utente, da quella fisica. Questa tecnica libera i programmatori da quel che riguarda i limiti della memoria. La memoria virtuale è pero difficile da realizzare e s’è usata scorrettamente, può ridurre di molto le prestazioni del sistema. 
 
1. INTRODUZIONE 
Gli algoritmi di gestione della memoria sono necessari perché, per l’attivazione di un processo, le istruzioni da eseguire si devono trovare all’interno della memoria fisica. Il primo metodo per far fronte  a tale requisito consiste nel collocare l’intero spazio d’indirizzi logici del processo relativo in memoria fisica. Il caricamento dinamico può aiutare ad attenuare gli effetti di tale limitazioni, ma richiede generalmente particolari precauzioni e un ulteriore impegno dei programmatori. La condizione che le istruzioni debbano esser nella memoria fisica sembra tanto necessaria quanto ragionevole, ma purtroppo riduce le dimensione dei programmi a valori strettamente correlati alle dimensioni della memoria fisica. Spesso i programmatori hanno codice per la gestione degli errori che vengono utilizzati molto di rado. La memoria virtuale si fonda sulla separazione della memoria logica percepita dall’utente dalla memoria fisica. Questa separazione perfette di offrire ai programmatori una memoria virtuale molto ampia, anche se la memoria fisica disponibile è più piccola. La memoria virtuale facilita la programmazione, poiché il programmatore non deve preoccuparsi della quanta di memoria fisica disponibile o di quale codice si debba inserire nella sezioni sovrapponibili, ma si può concentrare solo sul problema da risolvere. L’espressione spazio degli indirizzi virtuali si riferisce alla collocazione dei processi in memoria dal punto di vista logico. Da tale punto di vista un processo inizia in corrispondenza di un certo indirizzo logico e si estende alla memoria contigua.   
Si noti come allo heap sia lasciato di crescere verso l’alto nello spazio di memoria piche esso ospita la memoria allocata dinamicamente. Lo spazio vuoto e ben visibile che separo lo heap dalla pila è parte dello sazio degli indirizzi virtuali ma richiede pagine fisiche realmente esistenti colo nel caso che lo heap o la pila crescano. Qualora contenga buchi. Lo spazio degli indirizzi virtuali si definisce sparso.  Oltre a separare la memoria logica da quella fisica, la memoria virtuale offre il vantaggio di condividere i file e la memoria, mediante la condivisione delle pagine. Le librerie di sistema sono condivisibili da diversi processi associando l’oggetto condiviso a uno spazio degli indirizzi virtuali, procedimento detto mappatura. Benché ciascun processo vede le librerie condivise come parte del proprio spazio degli indirizzi virtuali, le pagine che ospitano effettivamente le librerie nella memoria fisica sono in condivisone tra tutti i processi. La memoria virtuale permette a  un processo di creare una regione di memoria condivisibile da un altro processo

2. PAGINAZIONE SU RICHIESTA 
Si consideri il caricamento in memoria di un eseguibile residente su disco. Una possibilità è quella di caricare l’intero programma nella memoria fisica al momento dell’esecuzione. Il problema però è che all’inizio non è detto che serva avere tutto il programma in memoria: se il codice fornisce all’avvio una lista di opzioni all’utente, è inutile caricare il codice per l’esecuzione di tutte le opzioni previste senza tener conto di quella effettivamente scelta dall’utente. Una strategia alternativa consiste nel caricare le pagine nel momento in cui servono raalmente; si tratta di una tecnica, detta paginazione su richiesta, comunemente adottata dai sistemi con mormora virtuale. Secondo questo schema, le pagine sono caricate in memoria solo usando richieste durante l’esecuzione del programma: ne consegue che le pagine che non vengono mai utilizzate non vengono mai caricate. I processi risiedono in memoria secondaria. Per eseguirli bisogna caricarli in memoria, non si carica in memoria mai una pagina che non sia necessaria. Nell’ambito della paginazione su richiesta, il modulo del So che si occupa della sostituzione della pagine si chiama paginature.  

|||||CONCETTI FONDAMENTALI
Quando un processo sta per esser caricato in memoria, il paginature ipotizza quali pagine saranno usate prima che il processo sia nuovamente caricato dalla memoria. Anziché caricare il memoria tutto il processo, il paginature trasferisce in memoria solo el pagine che ritiene necessarie. In questo modo è possibile evita il trasferimento in memoria dai pagine che no sono effettivamente usate riducendo il tempi d’avvicendamento e la quantità di memoria fisica richiesta. È necessario che l’architettura permetti di distinguere le pagine presenti in memoria tra quelle non. 
A tal fine è utilizzabile il bit di validità. Occorre notare che indicare una pagina non valida non sortisce alcun effetto se il processo non tenta mai di accedervi. Se il processo cerca di accedere a una pagina non presente in memoria, causa un’eccezione di pagina mancante. L’architettura di paginazione traducendo l’indirizzo attraverso la tabella delle pagine, nota che il bit è non valido e invia al SO un segnale il quale provvede a caricarla in memoria. 
? Si controlla una tabella interna per questo processo, di solito è conservata nel PCB 
? Se il riferimento era non valido si termina il processo. Se era valido ma la pagina non è in memoria se ne effettua l’inserimento 
? Si individua un frame libero dove collocare la pagina 
? Si programma un’operazione sui dischi per trasferire la pagina nel frame libero ? quando la lettura è completata, si modifica la tabella interna e la tabella delle pagine 
? Si riavvia l’istruzione interrotta dal segnale di eccezione.   
È addirittura possibile avviare un processo senza pagine in memoria e caricarle man man che vengono richieste.  

L’architettura deve fornire meccanismi per: 
? Tabella delle pagine. Questa tabella ha la capacita di contrassegnare un elemento come non valido attraverso un bit di validità 
? Memoria secondaria. Questa memoria conserva le pagine non presenti in memoria centrale. La sezione del disco usata per questo scopo richiama area d’avvicendamento. Il punto cruciale della paginazione su richiesta è che deve essere possibile continuare l’esecuzione nel punto in cui si interrompe per caricare una pagina mancante e riavviare il processo esattamente nel punto in cui è stato interrotto.  Il sistema di paginazione si colloca tra la CPU e la memoria di un calcolatore e deve essere completamente trasparenza al processo utente. 

|||||PRESTAZIONI
La paginazione su richiesta può aver un effetto rilevante sulle prestazioni di un calcolatore. Il motivo si può comprendere calcolando il tempo d’accesso effettivo per una  memoria con paginazione su richiesta. Per calcolare il temo d’accesso effettivo occorre conosce il tempo necessario alla gestione di un’assenza di pagina. A
lla presenza di un’assenza di pagina si esegue la seguente sequenza:  
? segnale d’eccezione al sistema operativo 
? Salvataggio dei registri utente ? Verifica che l’interruzione sai dovuta ad una mancanza di pagina 
? Controlla della correttezza del riferimento alla pagina e determinazione nella locazione della pagina nel disco.  
? Lettura dal disco e trasferimento nel frame libero 
? Durante l’attesa, allocazione della CPU a un altro processo utente 
? Ricezione di un’interruzione dal controllore del disco 
? Salvataggio dei registri e dello stato dell’altro processo utente 
? Verifica della provenienza dell’interruzione dal disco 
? Aggiornamento della tabella delle pagine e di altre tabelle per segnalare che la pagina richiesta è attualmente presente in memoria 
? Attesa che la CPU sia nuovamente assegnata a questo processo ? Recupero dei registri utente. 
Per mantenere a un livello ragionevole il rallentamento dovuto alla paginazione, si può permetter un’assenza di pagine ogni 399.990 accessi. Quindi è fondamentale tenere bassa la frequenza delle assenze. Dato che l’IO all’area di avvicendamento è più rapido rispetto al file system, il SO copia tutta l’immagine di un file nell’area di avvicendamento all’avvio ed esegue li la paginazione su richiesta.  
 
3. COPIATURA SU SCRITTURA 
Nella fork un processo figlio è un duplicato del padre. per ovviare la copiatura si può utilizzare la tecnica detta copiatura si scrittura il cui funzionamento si fonda sulla condivisione iniziale delle pagine da parte dei processi genitori e dei processi figli. Le pagine condivise si contrassegnano come pagine da copiare su scrittura significa che se un processo genitore o giglio scrive su una pagina condivisa, il sistema deve creare una copia di tale pagina. È chiaro che adoperando la tecnica della copiatura su scrittura, si copiano soltanto le pagine modificate se uno dei due processi mentre le altre sono condivisibili tra i processi. Quando è necessaria effettuare la tecnica della copiatura su scrittura, è importante capire da dove si attingeva la pagina libera necessaria. Molti sistemi forniscono insiemi di pagine libere. L’allocazione di queste pagine avviene di solito secondo una tecnica nota come azzeramene su richiesta prima dell’allocazione si riempiono di zeri le pagine cancellando il contenuto. La vfork offre la soluzione copiatura su scrittura.
 
4. SOSTITUZIONE DELLE PAGINE
 Se un processo di 10 pagine se ne impiega effettivamente solo la meta, la paginazione su richiesta fa risparmiare l?IO necessarie per caricare le 5 pagine che sono necessarie. Aumentando il grado di multiprogrammazione si soprassegna la memoria. Eseguendo 6 processi, ciascuno dei quali è formato da 10 pagine di cui solo 5 sono utilizzate, s’incrementerebbe l’utilizzo e la produttività della CPU e si risparmierebbero 10 frame. Se improvvisamente tutti hanno bisogno di tute le 10 pagine, sarebbero necessari 60 frame mentre ne sono disponibili solo 40. quindi bisogna decidere quanta memoria assegnare all’IO e quanta alle pagine dei programmi è un problema rilevante. Se durante l’esecuzione di un processo utente si verifica un’assenza di pagina, il So determina la locazione del disco in cui risiede la pagina desiderata, ma poi scopre che la lista dei frame libera è vuota: la memoria è tutta in uso. Questo problema è noto come sovrallocazione.  Il SP può scegliere di terminare il processo oppure scaricare l’intero processo liberando suoi frame e riducendo il livello di multiprogrammazione. 

|||||SOSTITUZIONE DI PAGINA
La sostituzione delle pagine segue il seguente criterio: se nessun frame è libero si può liberarne uno attualmente inutilizzato. È possibile liberalo scrivendo il suo contenuto nell’area d’avvicendamento e modificando la tabella delle pagine per indicare che la pagina non si trova più in memoria. Il frame liberato si può utilizzare per contenere la pagina che ha causato l’eccezione. Quindi: 
? S’individua la locazione nel disco 
? Si cerca un frame libero (se  esiste lo si usa altrimenti si libera scrivendo la pagina vittima nel disco) 
? Si scrive la pagina richiesta nel frame appena liberato 
? Si riavvia il processo utente 
Dato che sono necessari 2 trasferimenti se non esiste nessun frame libero, questo sovraccarico si può ridurre usando il bit di modifica. L’architettura deve disporre di un bit che imposta automaticamente ogni volta che nella pagina si scrive una parola. Quando si sceglie una pagina da sostituire si verifica il suo bit di modifica, se è inattivo la si può cancellare perché esiste una copia sul disco altrimenti bisogna essere prima copiata e poi sostituita.  Per realizzare la paginazione su richiesta, è necessario risolvere 2 problemi principali: occorre sviluppare un algoritmo di allocazione dei frame e uno per la sostituzione delle pagine. Esistono molti algoritmi per la sostituzione delle pagine probabilmente ogni SO ne ha uno suo.

|||||SOSTITUZIONE ORDINE ARRIVO FIFO
l’algoritmo più semplice è quello FIFO. Associa ad ogni pagine l’istante in cui è arrivata e se si deve sostituire un pagina si sceglie quella che sta da più tempo in memoria. Le sue prestazioni non sono sempre buone dato che se nel momento in cui si individua una pagina da sostituire e questa a breve serve di nuovo, questo comporta un ricaricamento della pagina aumentando la frequenza di pagina mancante

|||||SOSTITUZIONE OTTIMALE PAGINE
L’algoritmo ottimale è quello che fra tutti gli algoritmi presenta la minima frequenza di assenze di pagine e non presenta mai l’anomalia di Belady (la frequenza delle assenze di pagine può aumentare con l’aumentare del numero dei frame assegnati). L’algoritmo è semplice si sostituisce la pagina che no si userà per il periodo di tempo più a lungo. Sfortunatamente questo algoritmo è difficile da realizzare perché richiede la conoscenza futura delle successione dei riferimenti

|||||SOSTITUZIONE P USATE MENO RECENTEMENTE LRU
La distinzione fondamentale tra quello ottimale e il FIFO consiste nel fatto che il FIFO impiega l’istante in cui una pagina è stata caricata in memoria, mente l’algoritmo ottimale impiega l’istante in cui la pagina è usata. Usando come approssimazione di futuro vicino un passato recente, si sostituisce la pagina che non è stata usta per il periodo più lungo noto come LRU.  Si associa a ogni pagina l’istante e in cui è stata usata per l‘ultima volta. Quando si deve sostituire una pagina LRU sceglie quella che non è stata usata per il periodo più lungo. Questa strategia costituisce l’algoritmo ottimale di sostituzione delle pagine con ricerca all’indietro ne tempo. È considerato un algoritmo valido.
Il problema principale consiste nel determinare un ordine per i frame definito secondo il momento dell’ultimo usa. Si possono realizzare le seguenti soluzioni: 
? Contatore. Nel caso più semplice a ogni elemento della tabella delle pagine si associa un campo del momento d’uso e alla CPU si aggiunge un contatore che si incrementa a ogni riferimento alla memoria. Ogni volta che si fa un riferimento alla pagina si copia il contenuto del registro contatore nel campo del momento d’uso nella tabella relativa a quella specifica pagina. Occorre ricercare nella tabella delle pagine quella usata meno recentemente e aggiornare il campo. 
? Pila. Un altro metodo è usare una lista doppiamente concatenata che rappresenta il numero delle pagine. Ogni volta che si fa un riferimento a una pagina, la si estrae dalla pila e la so colloca in cima a quest’ultima. In questo modo in cima alla pila si torva sempre la pagina usata per ultima.

|||||SOSTITUZIONE P PER APPROSSIMAZIONE A LRU
Sono pochi i sistemi che utilizzano LRU. Molti sistemi offrono aiuto fornendo un bit di riferimento. Il bit di riferimento a una pagina è impostato automaticamente dall’architettura del sistema ogni volta che si fa riferimento alla pagina. Inizialmente azzera tutu i bit. Quando si inizia l’esecuzione di un processo utente, l’architettura del sistema imposta a 1 il bit associato o a ciascuna pagina. Dopo qualche tempo è possibile stabilire quali pagine sono stata usate semplicemente esamino i bit di riferimento: 
? Algoritmo con bit supplementari di riferimento. Ulteriori informazioni si possono ottenere registrando i bit di riferimento a intervalli regolari. È possibile conservare in una tabella in memoria una serie di bit per ogni pagina. A intervalli regolari il timer invia un segnale. Il SO shifta a destra di un bit. Se ad esempio i registri sono di 8 bit, si tiene conto di 8 intervalli. Se il registro vale 11111111 significa che è stato sempre utilizzato, se 11000100 e 01110111 significa che il primo è stato utilizzato più di frequente. La pagina quindi è associata ad un numero senza segno. Nel caos in cui i bit dei registri sono a lunghezza zero e si lascia solo il bit di riferimento, si utilizza l’algoritmo a seconda chance 
? Algoritmo con seconda chance. l’algoritmo di base è un algoritmo di sostituzione di tipo FIFO. Dopo aver selezionato una pagina si controlla il bit. Se vale zero si sostituisce, se vale 1 si porta a zero e si continua la scansione. La coda viene scandita in modo circolare. Se una pagina è usata abbastanza spesso, in modo che il suo bit di riferimento valga sempre 1, questa non viene mai sostituita. Una volta trovata la pagina vittima si sostituisce e si s’inserisce la nuova pagina. Nel caso peggiore in cui tutti i bit valgono 1, si deve scorrere tutta la lista per riportare i valori a 0. 
? Algoritmo con seconda chance migliorato. Si può considerare il bit di modifica con quello di riferimento come una coppia: (0,0) ne recentemente usato ne modificato- migliore pagina da sostituire (0,1) non usato recentemente ma modificato – prima di essere sostituita deve essere scritta in memoria secondaria (1,0) usato recentemente ma non modificato – probabilmente presto sarà di nuovo usata (1,1) usata e modificata Ogni pagina rientra in una di queste 4 classi. Si usa la scansione circolare ma anziché controllare se la pagina ha il bit di riferimento impostato a 1 e si esamina l’appartenenza a una classe e si seleziona la 1 pagina che si trova nella classe minima non vuoto. La coda deve essere scandita più volte prima di rimuovere una coda.  

|||||SOSTITUZIONE DELLE PAGINE BASATA SUL CONTEGGIO
Esistono altri algoritmi basati sul conteggio dei riferimenti fatti a ciascuna pagina: 
? Algoritmo di sostituzione delle pagine meno frequentemente usate. Richiede che si sostituisca la pagina con il conteggio più basso. La ragione di questa scelta è che una pagina usata attivamente ha un conteggio alto. Questo è sconveniente quando la pagina viene utilizzato molto nella fase iniziale e successivamente non usata, quindi ha un conteggio alto e non può essere sostituita 
? Algoritmo di sostituzione delle pagine più frequentemente usate. È basato sul fatto che probabilmente la pagina con il contatore più basso stata appena inserita e non è stata ancora usata.  

|||||ALGORITMI CON MEMORIZZAZIONE TRANSITORIA DELLE PAGINE 
Oltre agli algoritmi si possono usare anche altre procedure: generalmente i sistemi usano un gruppo di frame liberi. Quando si verifica un’assenza di pagina si scegli il frame vittima ma prima che si scriva in memoria secondaria si trasferisce la pagina richiesta in un frame libero del gruppo. Questo permette la rapida esecuzione senza che si attendi la scrittura nella memoria secondaria. Ogniqualvolta il dispositivo di paginazione è inattivo, scegli una pagina modificata, la si scrive nel disco e si riempie il suo bit di modifica. Questo permette di recuperare il tempo dell’inattività e di cancellarla qualora è scelta come vittima.   

|||||APPLICAZIONE E SOSTITUZIONE DELLA PAGINA
In alcuni casi le applicazioni che accedono ai dati tramite la memoria virtuale del sistema operativo non conseguono prestazione i miglior di quelle che il sistema, senza impiegare alcun buffer, potrebbe offrire. Alcuni programmi come i database utilizzano spazio di dischi a basso livello in modo da velocizzare alcune operazioni che non vengono effettuate senza file system.  